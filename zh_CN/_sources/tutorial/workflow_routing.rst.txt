
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/workflow_routing.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_workflow_routing.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_workflow_routing.py:


.. _routing:

Routing
==========================
在 AgentScope 中有两种实现 Routing 的方法，都简单易实现：

- 使用结构化输出的显式 routing
- 使用工具调用的隐式 routing

.. tip:: 考虑到智能体 routing 没有统一的标准/定义，我们遵循 `Building effective agents <https://www.anthropic.com/engineering/building-effective-agents>`_ 中的设置

显式 Routing
~~~~~~~~~~~~~~~~~~~~~~~~~~
在显式 routing 中，我们可以直接使用智能体的结构化输出来确定将消息路由到哪个智能体。

初始化 routing 智能体

.. GENERATED FROM PYTHON SOURCE LINES 20-83

.. code-block:: Python

    import asyncio
    import json
    import os
    from typing import Literal

    from pydantic import BaseModel, Field

    from agentscope.agent import ReActAgent
    from agentscope.formatter import DashScopeChatFormatter
    from agentscope.memory import InMemoryMemory
    from agentscope.message import Msg
    from agentscope.model import DashScopeChatModel
    from agentscope.tool import Toolkit, ToolResponse

    router = ReActAgent(
        name="Router",
        sys_prompt="你是一个路由智能体。你的目标是将用户查询路由到正确的后续任务，注意你不需要回答用户的问题。",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
    )


    # 使用结构化输出指定路由任务
    class RoutingChoice(BaseModel):
        your_choice: Literal[
            "Content Generation",
            "Programming",
            "Information Retrieval",
            None,
        ] = Field(
            description="选择正确的后续任务，如果任务太简单或没有合适的任务，则选择 ``None``",
        )
        task_description: str | None = Field(
            description="任务描述",
            default=None,
        )


    async def example_router_explicit() -> None:
        """使用结构化输出进行显式路由的示例。"""
        msg_user = Msg(
            "user",
            "帮我写一首诗",
            "user",
        )

        # 路由查询
        msg_res = await router(
            msg_user,
            structured_model=RoutingChoice,
        )

        # 结构化输出存储在 metadata 字段中
        print("结构化输出：")
        print(json.dumps(msg_res.metadata, indent=4, ensure_ascii=False))


    asyncio.run(example_router_explicit())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Router: 好的，我将为您创作一首诗。
    结构化输出：
    {
        "your_choice": "Content Generation",
        "task_description": null
    }




.. GENERATED FROM PYTHON SOURCE LINES 84-90

隐式 Routing
~~~~~~~~~~~~~~~~~~~~~~~~~
另一种方法是将下游智能体包装成工具函数，这样路由智能体就可以根据用户查询决定调用哪个工具。

我们首先定义几个工具函数：


.. GENERATED FROM PYTHON SOURCE LINES 90-140

.. code-block:: Python



    async def generate_python(demand: str) -> ToolResponse:
        """根据需求生成 Python 代码。

        Args:
            demand (``str``):
                对 Python 代码的需求。
        """
        # 示例需求智能体
        python_agent = ReActAgent(
            name="PythonAgent",
            sys_prompt="你是一个 Python 专家，你的目标是根据需求生成 Python 代码。",
            model=DashScopeChatModel(
                model_name="qwen-max",
                api_key=os.environ["DASHSCOPE_API_KEY"],
                stream=False,
            ),
            memory=InMemoryMemory(),
            formatter=DashScopeChatFormatter(),
            toolkit=Toolkit(),
        )
        msg_res = await python_agent(Msg("user", demand, "user"))

        return ToolResponse(
            content=msg_res.get_content_blocks("text"),
        )


    # 为演示目的模拟一些其他工具函数
    async def generate_poem(demand: str) -> ToolResponse:
        """根据需求生成诗歌。

        Args:
            demand (``str``):
                对诗歌的需求。
        """
        pass


    async def web_search(query: str) -> ToolResponse:
        """在网络上搜索查询。

        Args:
            query (``str``):
                要搜索的查询。
        """
        pass









.. GENERATED FROM PYTHON SOURCE LINES 141-143

之后，我们定义一个路由智能体并为其配备上述工具函数。


.. GENERATED FROM PYTHON SOURCE LINES 143-177

.. code-block:: Python


    toolkit = Toolkit()
    toolkit.register_tool_function(generate_python)
    toolkit.register_tool_function(generate_poem)
    toolkit.register_tool_function(web_search)

    # 使用工具模块初始化路由智能体
    router_implicit = ReActAgent(
        name="Router",
        sys_prompt="你是一个路由智能体。你的目标是将用户查询路由到正确的后续任务。",
        model=DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        ),
        formatter=DashScopeChatFormatter(),
        toolkit=toolkit,
        memory=InMemoryMemory(),
    )


    async def example_router_implicit() -> None:
        """使用工具调用进行隐式路由的示例。"""
        msg_user = Msg(
            "user",
            "帮我在 Python 中生成一个快速排序函数",
            "user",
        )

        # 路由查询
        await router_implicit(msg_user)


    asyncio.run(example_router_implicit())




.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    Router: {
        "type": "tool_use",
        "name": "generate_python",
        "input": {
            "demand": "生成一个快速排序函数"
        },
        "id": "call_778072e020c54d7099f7d0"
    }
    PythonAgent: 下面是一个使用 Python 编写的快速排序算法的实现。这个函数接受一个列表作为输入，并对其进行原地排序。

    ```python
    def quicksort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quicksort(left) + middle + quicksort(right)
    ```

    这是一个简洁的递归版本，它选择了列表中间的元素作为基准（pivot），然后创建了三个列表：`left` 用于存放比基准小的元素，`middle` 用来存放与基准相等的元素，`right` 则存放比基准大的元素。之后，函数会递归地对 `left` 和 `right` 列表进行排序，并将结果合并起来。

    如果你需要一个在原地进行排序的版本，不需要额外的空间来存储 `left`, `middle` 和 `right` 列表，我可以为你提供这样的代码。
    system: {
        "type": "tool_result",
        "id": "call_778072e020c54d7099f7d0",
        "name": "generate_python",
        "output": [
            {
                "type": "text",
                "text": "下面是一个使用 Python 编写的快速排序算法的实现。这个函数接受一个列表作为输入，并对其进行原地排序。\n\n```python\ndef quicksort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quicksort(left) + middle + quicksort(right)\n```\n\n这是一个简洁的递归版本，它选择了列表中间的元素作为基准（pivot），然后创建了三个列表：`left` 用于存放比基准小的元素，`middle` 用来存放与基准相等的元素，`right` 则存放比基准大的元素。之后，函数会递归地对 `left` 和 `right` 列表进行排序，并将结果合并起来。\n\n如果你需要一个在原地进行排序的版本，不需要额外的空间来存储 `left`, `middle` 和 `right` 列表，我可以为你提供这样的代码。"
            }
        ]
    }
    Router: 提供的 Python 代码实现了一个快速排序算法，它使用了简洁的递归方法。在这个版本中，列表中间的元素被选为基准值（pivot），函数会创建三个独立的列表：`left` 用于存放比基准小的元素，`middle` 存放与基准相等的元素，`right` 则存放比基准大的元素。之后，函数递归地对 `left` 和 `right` 列表进行排序，并将结果连接起来。

    ```python
    def quicksort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quicksort(left) + middle + quicksort(right)
    ```

    如果你需要一个在原地执行排序的版本，不需要额外的空间来存储 `left`, `middle` 和 `right` 列表，请告诉我，我可以为你生成这样的代码。你想要这个就地排序的版本吗？
    {
        "type": "tool_use",
        "name": "generate_python",
        "input": {
            "demand": "生成一个就地排序的快速排序函数"
        },
        "id": "call_d5a1bffbbe0b4f2999387e"
    }

    PythonAgent: 下面是一个就地排序的快速排序函数的 Python 代码。这个实现使用了 Lomuto 划分方案，并且是递归的。它会对输入列表进行就地排序，不需要额外的空间（除了递归栈）。

    ```python
    def quicksort(arr, low, high):
        if low < high:
            # Partition the array
            pi = partition(arr, low, high)

            # Recursively sort the elements before and after partition
            quicksort(arr, low, pi - 1)
            quicksort(arr, pi + 1, high)

    def partition(arr, low, high):
        # Choose the rightmost element as pivot
        pivot = arr[high]

        # Pointer for greater element
        i = low - 1

        # Traverse through all elements
        # compare each element with pivot
        for j in range(low, high):
            if arr[j] <= pivot:
                # If element smaller than pivot is found
                # swap it with the greater element pointed by i
                i = i + 1

                # Swapping the elements
                arr[i], arr[j] = arr[j], arr[i]

        # Swap the pivot element with the element at i+1
        arr[i + 1], arr[high] = arr[high], arr[i + 1]

        # Return the position from where partition is done
        return i + 1

    # Example usage:
    example_array = [10, 7, 8, 9, 1, 5]
    quicksort(example_array, 0, len(example_array) - 1)
    print("Sorted array:", example_array)
    ```

    要使用这个函数，你需要调用 `quicksort` 并传入数组和数组的起始与结束索引。上面的例子中，我们对一个整数数组进行了排序。如果你想要测试这段代码，请确保你有一个可以运行 Python 代码的环境。
    system: {
        "type": "tool_result",
        "id": "call_d5a1bffbbe0b4f2999387e",
        "name": "generate_python",
        "output": [
            {
                "type": "text",
                "text": "下面是一个就地排序的快速排序函数的 Python 代码。这个实现使用了 Lomuto 划分方案，并且是递归的。它会对输入列表进行就地排序，不需要额外的空间（除了递归栈）。\n\n```python\ndef quicksort(arr, low, high):\n    if low < high:\n        # Partition the array\n        pi = partition(arr, low, high)\n\n        # Recursively sort the elements before and after partition\n        quicksort(arr, low, pi - 1)\n        quicksort(arr, pi + 1, high)\n\ndef partition(arr, low, high):\n    # Choose the rightmost element as pivot\n    pivot = arr[high]\n\n    # Pointer for greater element\n    i = low - 1\n\n    # Traverse through all elements\n    # compare each element with pivot\n    for j in range(low, high):\n        if arr[j] <= pivot:\n            # If element smaller than pivot is found\n            # swap it with the greater element pointed by i\n            i = i + 1\n\n            # Swapping the elements\n            arr[i], arr[j] = arr[j], arr[i]\n\n    # Swap the pivot element with the element at i+1\n    arr[i + 1], arr[high] = arr[high], arr[i + 1]\n\n    # Return the position from where partition is done\n    return i + 1\n\n# Example usage:\nexample_array = [10, 7, 8, 9, 1, 5]\nquicksort(example_array, 0, len(example_array) - 1)\nprint(\"Sorted array:\", example_array)\n```\n\n要使用这个函数，你需要调用 `quicksort` 并传入数组和数组的起始与结束索引。上面的例子中，我们对一个整数数组进行了排序。如果你想要测试这段代码，请确保你有一个可以运行 Python 代码的环境。"
            }
        ]
    }
    Router: 下面是就地排序的快速排序函数的 Python 代码实现。这个版本使用了 Lomuto 划分方案，它会直接在给定的列表上进行操作而不需要额外的空间（除了递归调用栈）。

    ```python
    def quicksort(arr, low, high):
        if low < high:
            # 对数组进行划分
            pi = partition(arr, low, high)

            # 递归地对划分点两边的元素进行快速排序
            quicksort(arr, low, pi - 1)
            quicksort(arr, pi + 1, high)

    def partition(arr, low, high):
        # 选择最右边的元素作为基准值
        pivot = arr[high]

        # i 指向大于基准值的元素
        i = low - 1

        # 遍历从 low 到 high-1 的所有元素
        for j in range(low, high):
            # 如果当前元素小于或等于基准值
            if arr[j] <= pivot:
                # 将 i 向右移动一位，并交换 arr[i] 和 arr[j]
                i += 1
                arr[i], arr[j] = arr[j], arr[i]

        # 最后将基准值放到正确的位置
        arr[i + 1], arr[high] = arr[high], arr[i + 1]

        # 返回划分完成后的基准值位置
        return i + 1

    # 使用示例：
    example_array = [10, 7, 8, 9, 1, 5]
    quicksort(example_array, 0, len(example_array) - 1)
    print("Sorted array:", example_array)
    ```

    这段代码定义了 `quicksort` 函数和辅助的 `partition` 函数。要使用这个快速排序功能，你只需调用 `quicksort` 并传入待排序的数组以及数组的第一个和最后一个索引。如例子所示，我们对一个整数数组进行了排序。如果你有 Python 环境的话，你可以运行这段代码来测试它的效果。





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (1 minutes 26.500 seconds)


.. _sphx_glr_download_tutorial_workflow_routing.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: workflow_routing.ipynb <workflow_routing.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: workflow_routing.py <workflow_routing.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: workflow_routing.zip <workflow_routing.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
