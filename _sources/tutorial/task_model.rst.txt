
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "tutorial/task_model.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_tutorial_task_model.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_tutorial_task_model.py:


.. _model:

Model
====================

In this tutorial, we introduce the model APIs integrated in AgentScope, how to use them and how to integrate new model APIs.
The supported model APIs and providers include:

.. list-table::
    :header-rows: 1

    * - API
      - Class
      - Compatible
      - Streaming
      - Tools
      - Vision
      - Reasoning
    * - OpenAI
      - ``OpenAIChatModel``
      - vLLM, DeepSeek
      - ✅
      - ✅
      - ✅
      - ✅
    * - DashScope
      - ``DashScopeChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅
    * - Anthropic
      - ``AnthropicChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅
    * - Gemini
      - ``GeminiChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅
    * - Ollama
      - ``OllamaChatModel``
      -
      - ✅
      - ✅
      - ✅
      - ✅

To provide unified model interfaces, the above model classes has the following common methods:

- The first three arguments of the ``__call__`` method are ``messages`` , ``tools`` and ``tool_choice``, representing the input messages, JSON schema of tool functions, and tool selection mode, respectively.
- The return type are either a ``ChatResponse`` instance or an async generator of ``ChatResponse`` in streaming mode.

.. note:: Different model APIs differ in the input message format, refer to :ref:`prompt` for more details.

The ``ChatResponse`` instance contains the generated thinking/text/tool use content, identity, created time and usage information.

.. GENERATED FROM PYTHON SOURCE LINES 66-91

.. code-block:: Python

    import asyncio
    import json
    import os

    from agentscope.message import TextBlock, ToolUseBlock, ThinkingBlock, Msg
    from agentscope.model import ChatResponse, DashScopeChatModel

    response = ChatResponse(
        content=[
            ThinkingBlock(
                type="thinking",
                thinking="I should search for AgentScope on Google.",
            ),
            TextBlock(type="text", text="I'll search for AgentScope on Google."),
            ToolUseBlock(
                type="tool_use",
                id="642n298gjna",
                name="google_search",
                input={"query": "AgentScope?"},
            ),
        ],
    )

    print(response)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    ChatResponse(content=[{'type': 'thinking', 'thinking': 'I should search for AgentScope on Google.'}, {'type': 'text', 'text': "I'll search for AgentScope on Google."}, {'type': 'tool_use', 'id': '642n298gjna', 'name': 'google_search', 'input': {'query': 'AgentScope?'}}], id='2025-08-27 03:35:44.277_8536e7', created_at='2025-08-27 03:35:44.277', type='chat', usage=None, metadata=None)




.. GENERATED FROM PYTHON SOURCE LINES 92-93

Taking ``DashScopeChatModel`` as an example, we can use it to create a chat model instance and call it with messages and tools:

.. GENERATED FROM PYTHON SOURCE LINES 93-118

.. code-block:: Python



    async def example_model_call() -> None:
        """An example of using the DashScopeChatModel."""
        model = DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=False,
        )

        res = await model(
            messages=[
                {"role": "user", "content": "Hi!"},
            ],
        )

        # You can directly create a ``Msg`` object with the response content
        msg_res = Msg("Friday", res.content, "assistant")

        print("The response:", res)
        print("The response as Msg:", msg_res)


    asyncio.run(example_model_call())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The response: ChatResponse(content=[{'type': 'text', 'text': 'Hello! How can I assist you today?'}], id='2025-08-27 03:35:46.222_9c71aa', created_at='2025-08-27 03:35:46.222', type='chat', usage=ChatUsage(input_tokens=10, output_tokens=9, time=1.9437, type='chat'), metadata=None)
    The response as Msg: Msg(id='9NMhFdtySiA3iM4cKnxiTm', name='Friday', content=[{'type': 'text', 'text': 'Hello! How can I assist you today?'}], role='assistant', metadata=None, timestamp='2025-08-27 03:35:46.222', invocation_id='None')




.. GENERATED FROM PYTHON SOURCE LINES 119-126

Streaming
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
To enable streaming model, set the ``stream`` parameter in the model constructor to ``True``.
When streaming is enabled, the ``__call__`` method will return an **async generator** that yields ``ChatResponse`` instances as they are generated by the model.

.. note:: The streaming mode in AgentScope is designed to be **cumulative**, meaning the content in each chunk contains all the previous content plus the newly generated content.


.. GENERATED FROM PYTHON SOURCE LINES 126-156

.. code-block:: Python



    async def example_streaming() -> None:
        """An example of using the streaming model."""
        model = DashScopeChatModel(
            model_name="qwen-max",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            stream=True,
        )

        generator = await model(
            messages=[
                {
                    "role": "user",
                    "content": "Count from 1 to 20, and just report the number without any other information.",
                },
            ],
        )
        print("The type of the response:", type(generator))

        i = 0
        async for chunk in generator:
            print(f"Chunk {i}")
            print(f"\ttype: {type(chunk.content)}")
            print(f"\t{chunk}\n")
            i += 1


    asyncio.run(example_streaming())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The type of the response: <class 'async_generator'>
    Chunk 0
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1'}], id='2025-08-27 03:35:47.125_332294', created_at='2025-08-27 03:35:47.126', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=1, time=0.90223, type='chat'), metadata=None)

    Chunk 1
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 '}], id='2025-08-27 03:35:47.173_e40fb8', created_at='2025-08-27 03:35:47.173', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=2, time=0.949482, type='chat'), metadata=None)

    Chunk 2
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2'}], id='2025-08-27 03:35:47.226_da5ebf', created_at='2025-08-27 03:35:47.226', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=3, time=1.002947, type='chat'), metadata=None)

    Chunk 3
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 '}], id='2025-08-27 03:35:47.274_b63ac3', created_at='2025-08-27 03:35:47.274', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=4, time=1.05113, type='chat'), metadata=None)

    Chunk 4
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 '}], id='2025-08-27 03:35:47.466_7489cc', created_at='2025-08-27 03:35:47.466', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=8, time=1.242748, type='chat'), metadata=None)

    Chunk 5
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 '}], id='2025-08-27 03:35:47.655_d008d0', created_at='2025-08-27 03:35:47.655', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=12, time=1.431559, type='chat'), metadata=None)

    Chunk 6
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 '}], id='2025-08-27 03:35:47.845_3c6746', created_at='2025-08-27 03:35:47.845', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=16, time=1.621955, type='chat'), metadata=None)

    Chunk 7
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10'}], id='2025-08-27 03:35:48.048_42d91a', created_at='2025-08-27 03:35:48.048', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=20, time=1.824442, type='chat'), metadata=None)

    Chunk 8
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 '}], id='2025-08-27 03:35:48.216_53c596', created_at='2025-08-27 03:35:48.216', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=24, time=1.992795, type='chat'), metadata=None)

    Chunk 9
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 1'}], id='2025-08-27 03:35:49.181_5932bc', created_at='2025-08-27 03:35:49.181', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=28, time=2.957949, type='chat'), metadata=None)

    Chunk 10
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14'}], id='2025-08-27 03:35:50.114_a71164', created_at='2025-08-27 03:35:50.114', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=32, time=3.890937, type='chat'), metadata=None)

    Chunk 11
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 '}], id='2025-08-27 03:35:50.323_958565', created_at='2025-08-27 03:35:50.323', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=36, time=4.099382, type='chat'), metadata=None)

    Chunk 12
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 1'}], id='2025-08-27 03:35:50.500_280634', created_at='2025-08-27 03:35:50.500', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=40, time=4.276957, type='chat'), metadata=None)

    Chunk 13
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18'}], id='2025-08-27 03:35:50.692_0ceaa4', created_at='2025-08-27 03:35:50.692', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=44, time=4.468267, type='chat'), metadata=None)

    Chunk 14
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 '}], id='2025-08-27 03:35:50.878_6ea85e', created_at='2025-08-27 03:35:50.878', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=48, time=4.654563, type='chat'), metadata=None)

    Chunk 15
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20'}], id='2025-08-27 03:35:51.017_ab2ca5', created_at='2025-08-27 03:35:51.017', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=50, time=4.794031, type='chat'), metadata=None)

    Chunk 16
            type: <class 'list'>
            ChatResponse(content=[{'type': 'text', 'text': '1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20'}], id='2025-08-27 03:35:51.033_5cd274', created_at='2025-08-27 03:35:51.033', type='chat', usage=ChatUsage(input_tokens=27, output_tokens=50, time=4.809319, type='chat'), metadata=None)





.. GENERATED FROM PYTHON SOURCE LINES 157-161

Reasoning
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
AgentScope supports reasoning models by providing the ``ThinkingBlock``.


.. GENERATED FROM PYTHON SOURCE LINES 161-186

.. code-block:: Python



    async def example_reasoning() -> None:
        """An example of using the reasoning model."""
        model = DashScopeChatModel(
            model_name="qwen-turbo",
            api_key=os.environ["DASHSCOPE_API_KEY"],
            enable_thinking=True,
        )

        res = await model(
            messages=[
                {"role": "user", "content": "Who am I?"},
            ],
        )

        last_chunk = None
        async for chunk in res:
            last_chunk = chunk
        print("The final response:")
        print(last_chunk)


    asyncio.run(example_reasoning())





.. rst-class:: sphx-glr-script-out

 .. code-block:: none

    The final response:
    ChatResponse(content=[{'type': 'thinking', 'thinking': 'Okay, the user asked "Who am I?" which is a pretty broad question. Let me think about how to approach this.\n\nFirst, I need to consider the context. The user might be asking about their identity in a general sense, or maybe they\'re looking for help with something specific. Since they mentioned "Who am I?" without any additional info, it\'s a bit vague.\n\nI should start by acknowledging that the question is open-ended. Maybe they\'re looking for a philosophical answer, or perhaps they want to know more about themselves. But since I can\'t know their personal details, I need to make that clear.\n\nI should also think about possible interpretations. They might be asking for my identity as an AI, but the question is "Who am I?" which refers to them. So, I need to explain that I can\'t know their personal information and offer to help them explore their identity.\n\nI should check if there\'s a cultural or psychological angle here. Sometimes people ask this when they\'re feeling lost or seeking self-discovery. Maybe they\'re looking for guidance on self-reflection.\n\nAlso, I should avoid making assumptions. It\'s important to stay neutral and not jump to conclusions. The user might be testing me or just curious.\n\nI need to structure the response to be helpful. Start by explaining that I can\'t know their personal identity, then offer to help them explore their own thoughts. Maybe suggest questions they can ask themselves or recommend resources.\n\nWait, but the user might be expecting a more direct answer. However, since I don\'t have access to their personal data, I can\'t provide that. So, the best approach is to be transparent and offer assistance in a different way.\n\nI should also make sure the tone is empathetic and supportive. Let them know it\'s okay to feel uncertain and that I\'m here to help them work through it.\n\nIs there anything else I need to consider? Maybe the user is using this as a way to start a conversation about their identity. I should keep the door open for them to share more if they\'re comfortable.\n\nAlright, putting it all together: start with a clear statement about not knowing their personal identity, explain the limitations, then offer to help them explore their own thoughts and feelings. Keep the tone friendly and supportive.'}, {'type': 'text', 'text': 'The question "Who am I?" is profound and deeply personal, often touching on identity, purpose, and self-awareness. While I can’t know your specific identity or life experiences, I can offer some guidance to help you explore this question:\n\n1. **Self-Reflection**: Consider your values, beliefs, passions, and experiences. What makes you unique? How do you define yourself (e.g., roles, relationships, goals)?\n2. **Philosophical Perspective**: Many thinkers (like Sartre or Buddha) suggest that identity is fluid and shaped by choices, actions, and perspectives. Are you defined by your past, your potential, or your present?\n3. **Ask Yourself**: \n   - What brings me joy or meaning?\n   - What are my core values?\n   - How do I want to grow or change?\n4. **External Influences**: Your identity is also shaped by culture, relationships, and society. How do these factors influence your sense of self?\n\nIf you’re feeling lost or curious, journaling, meditation, or talking to someone you trust might help. If this is a metaphorical question (e.g., about purpose), I’d be happy to explore it further with you! What’s on your mind? 😊'}], id='2025-08-27 03:36:01.071_832109', created_at='2025-08-27 03:36:01.071', type='chat', usage=ChatUsage(input_tokens=12, output_tokens=719, time=10.035097, type='chat'), metadata=None)




.. GENERATED FROM PYTHON SOURCE LINES 187-195

Tools API
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Different model providers differ in their tools APIs, e.g. the tools JSON schema, the tool call/response format.
To provide a unified interface, AgentScope solves the problem by:

- Providing unified tool call block :ref:`ToolUseBlock <tool-block>` and tool response block :ref:`ToolResultBlock <tool-block>`, respectively.
- Providing a unified tools interface in the ``__call__`` method of the model classes, that accepts a list of tools JSON schemas as follows:


.. GENERATED FROM PYTHON SOURCE LINES 195-216

.. code-block:: Python


    json_schemas = [
        {
            "type": "function",
            "function": {
                "name": "google_search",
                "description": "Search for a query on Google.",
                "parameters": {
                    "type": "object",
                    "properties": {
                        "query": {
                            "type": "string",
                            "description": "The search query.",
                        },
                    },
                    "required": ["query"],
                },
            },
        },
    ]








.. GENERATED FROM PYTHON SOURCE LINES 217-222

Further Reading
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
- :ref:`message`
- :ref:`prompt`



.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 16.798 seconds)


.. _sphx_glr_download_tutorial_task_model.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: task_model.ipynb <task_model.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: task_model.py <task_model.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: task_model.zip <task_model.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
